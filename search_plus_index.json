{"./":{"url":"./","title":"简介","keywords":"","body":"Introduction This is a book powered by GitBook "},"kotlin/kotlin整理学习计划.html":{"url":"kotlin/kotlin整理学习计划.html","title":"Kotlin篇章","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Kotlin任务清单 jetpack 记住 Kotlin任务清单 [x] kotlin数据类型 [x] 集合篇 [x] 神奇的条件循环语句 [x] 面向对象类 [x] 神奇的函数+lambda表达式+扩展函数+内联函数 [x] 作用域函数 [x] 超牛B的操作符重载+中缀符 [ ] 高阶函数的使用 [ ] kotlin泛型篇 [ ] 牛B的委托机制 [ ] DSL语法 [ ] 超级复杂的协程 [ ] kotlin总结 jetpack [ ] Navigation学习使用 [ ] DataBinding学习使用 [ ] LiveData&ViewModel学习使用 [ ] Paging分页加载库的学习使用 [ ] 理解组件化如何搭建 [ ] 总结尝试搭建MVVM架构+组件化架构 记住 面向对象的时候说下包集合的时候说下数组扩展函数，说下集合的那几个扩展方法的实现原理 组件化如何处理多个model的Application问题 可以使用在组件中每个applacation都实现一个接口（返回一个优先级），将app注册在mainfist中 壳app，直接去反射创建对象，并通过优先级完成调用顺序 "},"kotlin/Kotlin数据类型.html":{"url":"kotlin/Kotlin数据类型.html","title":"1.kotlin数据类型","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 boolean类型 数字类型 数字类型做比较 类型转换 位运算 区间 Range Char 字符串 直接索引访问字符 字符串模板 更夸张的字符串 boolean类型 kotlin不像java区分，boolean和Boolean。只存在Boolean类型 val b: Boolean = true val b1: Boolean = false 数字类型 类型 字节长度 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 /** * 默认都是double类型 */ val d = 2.0 /** * 默认都是float类型,使用f结尾 */ val f = 2.0f /** * 16进制表示 */ val hex = 0XFF /** * 二级制表示 */ val number = 0b00000001 这里有一个特时点，Float和Double存在，一个静态变量NaN（不是一个数的数） // 不会抛异常 val naN: Double = 0.0 / 0.0 // 不会抛异常 val naN2: Float = 0.0f / 0.0f println(naN) println(naN2) println(naN == Double.NaN) println(naN2 == Float.NaN) // 抛异常 val intVar = 0 / 0 输出结果： NaN NaN false false Exception in thread \"main\" java.lang.ArithmeticException: / by zero at com.qihoo.kot.KotlinDemoKt.main(KotlinDemo.kt:13) at com.qihoo.kot.KotlinDemoKt.main(KotlinDemo.kt) 数字类型做比较 kotlin中==相当于调用equals方法，在数字做大小比较时候，具有严格的校验，不同的数据类型是无法作比较的，在编译时期就会报错（包括赋值） 类型转换 转换 toByte() toShort() toInt() toLong() toFloat() toDouble() toChar() 位运算 Kotlin不在像java，使用,>>,|,&的操作符进行位运算了 运算符 对比java shl 有符号左移（java的） shr 有符号右移（java的>>） ushr 有符号右移（java的>>>） and 位与（java的&） or 位或（java的` `） xor 位异或（java的^） inv 位非（java的~） 巧妙的位运算 fun main() { val type1 = 0X10000000 val type2 = 0X20000000 val type3 = 0X40000000 val type4 = 0X80000000 var flag = type1 or type2 or type3 if ((flag and type1) != 0) { println(\"包含type\") } if ((flag and type2) != 0) { println(\"包含type2\") } if ((flag and type3) != 0) { println(\"包含type3\") } if ((flag.toLong() and type4) != 0L) { println(\"包含type4\") } // 去除规则 当前flag 包含 type1和type2规则,去除type2的规则 flag = flag and type2.inv() } 区间 Range Kotlin特殊的类型，和数学上的区间概念属于同一概念 闭区间 // 0到1024的闭区间[0,1024] val range = 1..1024 半开区间 // 0到1024的闭区间[0,1024) val openRange = 1 until 1024 ==可以考虑下区间是怎么实现的？== Char 这个和java的一样，占2个字节，没啥好说的。 字符串 Kotlin相比较java字符串，更为的强大 直接索引访问字符 val c = str[0] for (c in str) { println(c) } 字符串模板 其实很多语言都有这个功能。java中+拼接字符串的形式，已经成为过去式，复杂丶难用丶易出错 val a = 100 val b = 101 val str = \"a+b=${a + b}\" println(str) 这个模板很强大（其他语言玩烂的功能），只需要通过$连接，如果就是区一个字段的值$XXX字段名，如果是个运算表达公式，需要${表达式} 更夸张的字符串 当我们要输出，一个有个事的模板字符串，使用\\n很是麻烦，Kotlin也为我们想到了，只需要定义字符串使用\"\"\"XXXX内容\"\"\" // 当然也是支持字符串模板的 val superStr=\"\"\"aaaa |dddd |s |asfa${a+b} \"\"\".trimMargin() println(superStr) "},"kotlin/集合篇.html":{"url":"kotlin/集合篇.html","title":"2.集合篇","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 集合 不可变集合 可变集合 kotlin集合方法的封装 list扩展 集合 Kotlin集合，没有重复造轮子。完全兼容java的集合。并且提供的集合框架，最终都会映射成java的集合框架 不可变集合 /** * kotlin 不可变集合(纯属自淫) * 都不带有add方法和remove方法 * * 为何说自淫呢?其实,不可变的集合,就是给编译器看的.编译器不让你写remove方法,最终编译的class文件都映射成了java的集合 */ val listOf = listOf(\"1\", \"2\", \"3\") val setof= setOf(\"1\",\"2\",\"3\") val map = mapOf(Pair(\"1\", 1), Pair(\"2\", 2)) // 为啥可以用to连接呢?(后续讲到神奇的中缀符号,类似自定义操作符) val mapof = mapOf(\"1\" to 1, \"2\" to 3) 可变集合 /** * kotlin中可变集合 * 同理在最终编译还是映射成java的集合 */ val list = mutableListOf(\"1\", \"2\", \"3\") val mutableMapOf = mutableMapOf(1 to 2, 2 to 3) val mutableSetOf = mutableSetOf(1 , 3) /** * 当然kotlin也可以直接使用Java的 */ val javaList = ArrayList() val javaMap = HashMap() val javaSet = HashSet() 总结下，kotlin中虽有很多集合，看似创造了很多集合。其实这些集合的本质都是java的集合。只是在java的集合上做了一层包装。为我们提供了很多有趣的方法（如果想看kotlin集合的光屁屁，自行反编译成java的代码） kotlin集合方法的封装 list扩展 可直接通过索引获取 val javaList = ArrayList() val s = javaList[0] 取区间 val javaList = ArrayList() javaList.slice(0..2) 集合直接相加减 val list = mutableListOf(\"1\", \"2\", \"3\") val javaList = ArrayList() val listAdd = list + javaList 遍历，转换，过滤 val javaList = ArrayList() /** * 数据转换 */ javaList.map { } /** * 过滤 */ javaList.filter { } /** * flatMap转换 */ javaList.flatMap { } /** * 遍历 */ javaList.forEach { } 删除 /** * 对象删除 */ javaList.remove(\"\") /** * 索引删除 */ javaList.removeAt(0) /** * 条件删除 */ javaList.removeIf { } ==是不是很多强大的方法，其实实现原理都很简单，都是对集合的封装。这些牛B多功能全都归功于，koltin的扩展函数（后续慢慢讲）== 等等还有很多操作符，map和set自行点击->更多内容 "},"kotlin/kotlin循环选择分支.html":{"url":"kotlin/kotlin循环选择分支.html","title":"3.神奇的条件循环语句","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 if表达式 When表达式 for循环 while循环 Kotlin的分支比较强大具有返回值的功能 if表达式 val str = \"121\" // if具有返回值的功能,如果要用返回值.一定要有 else val lengthType = if (str.length > 3) { \"大于3\" } else { \"小于3\" } When表达式 When类似，java的switch语句，但是更加的强大。不在像java那样，switch那样只支持简单的类型 fun main() { /** * 可以看到,when也具有返回值的功能,并且支持 is */ val str = \"121\" val flag = when (str) { \"121\" -> { 1 } is String -> { 2 } else -> { 3 } } /** * when语句也可以不设置参数,可以替换if else语法 */ when { str.length > 0 -> { } else -> { } } } for循环 for循环，kotlin给了过多的方案。但是没有了java以前的我们经常的fori的形式遍历。（为啥没有？我的想法是，已经有足够的方案放弃这个方式了，比如repeat方法和遍历区间都可以实现功能） val range = 1..3 // 可以通过 in 关键词进行循环遍历(这里强调下,什么样的对象支持in遍历,遍历的对象实现了Iterable接口) for (i in range) { } val array = IntArray(10) // 只遍历index for (i in array.indices) { println(array[i]) } // 遍历index和value for (withIndex in array.withIndex()) { println(\"索引:${withIndex.index} 值:${withIndex.value}\") } // 上面的可以缩写成,为何可以这样写，其实就是重载操作符了 for ((index,value) in array.withIndex()) { println(\"索引:$index 值:$value\") } 常见的计数循环方法： kotlin没有了java的 for(i=0;i * 使用Range来实现计数循环 */ for (i in 1..10) { } /** * 同上 */ for (i in 1 until 10) { } /** * 向下减 */ for (i in 10 downTo 1) { } /** * step跳跃 没循环一次就条鱼2个 输出结果10 8 6 4 2 */ for (i in 10 downTo 1 step 2) { println(i) } /** * 循环执行10,本质还是Range */ repeat(10){ } } ``` while循环 和java的一致 "},"kotlin/面向对象之类.html":{"url":"kotlin/面向对象之类.html","title":"4.面向对象","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 包 创建一个类 构造函数 构造函数init方法 构造方法权限符修饰 继承 覆盖属性和方法 内部类+静态内部类 伴生对象 单利类 实体类 抽象类 密封类 密封类的好处 类的映射typealias 包 在java的世界中，一个.java文件就对应一个类（先不说内部类），并且类的名字要和文件名相同，这是铁的规定。而下kotlin中，打破了这种秩序，每个.kt文件，已经不再是一个类的约束。你要是喜欢，你可以一个kt文件写完整个程序。哪我在文件中定义的函数，字段对应的是什么呢？我们统称为包级函数，他不属于任何一个类，任何地方都可以调用。 定义： /** * 我在外面定义类 */ val va = \"我是包级字段\" /** * 我在外面定义函数 */ fun test(){ println(\"我是包级函数,谁都可以拥有我!\") } 调用： /** * 可以看到用的时候,必须导入（从这里可以看出定义的包级函数同方法名和签名不可以定义在相同包下的不同kt文件） */ import com.qihoo.kotlin.test import com.qihoo.kotlin.va /** * 这属于另外一个kt文件 */ fun main() { test() val value = va } 包级重新命名，比如说2个kt文件（不同包下）都有test()方法。我们在另外一个kt文件中都要调用，会出现奇异。2中解决方法，补充方法全路径和包级重新命名 /** * 注意这是demo包下 */ package com.qihoo.kotlin.demo fun test(){ println(\"我是com.qihoo.kotlin.demo包下kt.kt文件下的test方法\") } /** * 注意这是demo1包下 */ package com.qihoo.kotlin.demo1 fun test(){ println(\"我是com.qihoo.kotlin.demo1包下kt.kt文件下的test方法\") } ==定义的2个都是在不同包下，名字都为kt.kt的文件，此时引用就有冲突==解决方案1 // 导入的demo包下的test import com.qihoo.kotlin.demo.test fun main() { /** * 可以补充全路径名称调用 */ test() com.qihoo.kotlin.demo1.test() } 解决方案2 as 关键词从新命名 as关键词，之前的作用是强转。这是第二个作用，包级函数重新命名 /** * 将demo包下的test函数 从新命名 DemoTest */ import com.qihoo.kotlin.demo.test as DemoTest /** * 将demo1包下的test函数 从新命名 Demo1Test */ import com.qihoo.kotlin.demo1.test as Demo1Test fun main() { // 直接调用 DemoTest() Demo1Test() } ==这里补充下，不管方法可以通过 as 关键词重新命名。只要通过import导入的都可以重新命名（字段，类）！== 创建一个类 class DemoClass 这就定义了一个类，但是这个类，没有任何意义。Ktolin默认定义的类，都是public final类型的。 构造函数 kotlin和java一样鸡贼，都有一个隐藏的默认无参构造函数。但是kotlin的默认无参构造函数和java的写法有点不同。如果要重写默认的无参构造函数，必须这样定义。 class Empty(name: String, age: Int) 这里补充一个知识点 // 这样定义的 class Empty(name: String, age: Int) // 通过val或者var修饰的构造参数变量，有什么区别？ class Empty(var name: String, var age: Int) ==如果是在构造函数中，没有通过val或者var修饰的。这些属性，并不会变成 成员属性（也就是创建的对象，无法引用。类中根本没有这个成员字段），反之就会生成== /** * val修饰 */ class Empty( val name:String,val age:Int) fun main() { /** * 调用已经可以发现name和age已经能调用到了 */ val empty = Empty(\"awen\", 18) println(\"${empty.name} ${empty.age}\") } 定义多个构造函数： /** * val修饰 */ class Empty(val name: String, val age: Int) { var isGay: Boolean = false var sex: String = \"女\" /** * 定义其他的构造函数,一定要调用默认的构造函数(其实这种的一半不这样写,kotlin给我们提供给了默认值的概念) */ constructor(name: String, age: Int, sex: String) : this(name, age) { this.sex = sex } constructor(name: String, age: Int, sex: String,isGay:Boolean) : this(name, age,sex) { this.isGay = isGay } } ==如果要定义这样的类，一般不这样写。可以使用参数默认值的功能== class Empty(val name: String, val age: Int, var sex: String = \"女\", var isGay: Boolean = false) 是不是精简了很多。 构造函数init方法 曾几何时，java中自定义view的时候，需要些N个够赞函数，然后每个函数都要写一次init方法，做初始化画笔等功能。kotlin已经为我们考虑到了这。每个类都有一个init方法，在类创建的时候调用。 class Empty(val name: String, val age: Int, var sex: String = \"女\", var isGay: Boolean = false){ init { println(\"对象创建:$name $age $sex $isGay\") } /** * 可与已定义多个init方法,顺序上到下 */ init { println(\"对象创建22:$name $age $sex $isGay\") } } 构造方法权限符修饰 /** * 构造方法权限符修饰 */ class DemoClass private constructor(name:String=\"阿文\"){ private constructor(name: String, age: Int) : this(name) } 继承 前面说过kotlin的默认定义的class是默认final类型的，也就是不可以继承。如果要继承必须使用open权限符修饰。 /** * open修饰 */ open class A(val name: String) /** * B继承A类 */ class B(name: String) : A(name) 注意：如过子类没有主构造函数只有次构造函数，父类也没有主构造函数，只有次构造函数。 /** * open修饰 */ open class A { constructor(name: String) } /** * B继承A类 */ class B : A { constructor(name: String, age: Int) : super(name) } 覆盖属性和方法 和java不同的是，kotlin是可以覆盖属性的不光是覆盖方法。覆盖方法就不说了 /** * open修饰 */ open class A { // value记得open open val value = 0 } /** * B继承A类 */ class B : A() { // 覆盖A的value值 override val value = 1 } 覆盖方法： /** * B继承A类 */ class B : A() { // 覆盖A的value值 override val value = 1 override fun test() { super.test() val superValue = super.value println(\"父类的$superValue\") } } 内部类+静态内部类 定义静态内部类 open class A { /** * 默认是静态内部类 */ class B(){ } } 定义内部类 open class A { val value = 0 /** * 默认是内部类 */ inner class B() { fun test(){ // 持有外部了id引用了 val d = value } } } 伴生对象 伴生对象，我的理解就是每个类的静态方法和静态变量（当然大多数我们都定义到包级函数和变量了） open class A { /** * 定义伴生对象必须使用 companion object */ companion object { val value = 0 fun test() { } } } fun main() { A.value A.test() } 补充: kotlin中伴生对象本质是在类的内部生成一个静态内部类（Companion类），并且创建了一个本类型的静态对象。如果java想调用呢？ class TestCompanionObj { companion object { fun get(){ println(\"伴生方法\") } } } public static void main(String[] args) { /** * java调用 */ TestCompanionObj.Companion.get(); } 如果java不像写Companion，可以通过@jvmStatic修饰伴生方法 class TestCompanionObj { companion object { // 注意这里 @JvmStatic fun get(){ println(\"伴生方法\") } } } public static void main(String[] args) { /** * java即可直接调用 */ TestCompanionObj.get(); } 这里kotlin有个和java不同，在java中静态方法是支持继承的。但是在koltin中静态方法是不支持继承的，伴生对象也不支持，但是子类的内部可以调用。 /** * 父类 */ open class ParentCompanionObj { companion object { @JvmStatic fun get() { println(\"伴生方法\") } } } /** * 子类 */ class ChildCompanionObj : ParentCompanionObj() { companion object { @JvmStatic fun childGet(){ /** * 调用父类的伴生方法get */ get() } } } fun main() { /** * 能调用自己的伴生方法,但是不能调用父类的伴生方法 * (java是可以的哦) */ ChildCompanionObj.childGet() } 单利类 我们经常写单利，kotlin也为我们考虑到了这些。如何快速创建一个单利的类呢？ /** * 使用关键词 object * 本质使用的饿汉式单利(思考下懒汉式单利怎么写) */ object Single{ fun call(){ } } fun main() { // 只有一个对象,不允许创建对象 Single.call() } 实体类 java中我们经常创建一个实体对象，有get set toString方法，kotlin为我们开发方便，也提供了这种类型的类。 /** * 这样的类,toString,equals,hashcode等方法都被自动写了.其中包含了componentN方法(还记得这个重在操作符的作用吗?) */ data class Play(val name: String, val time: Int) fun main() { val play = Play(\"阿文\", 10000) // 复习下 componentN val (name, time) = play println(\"$name $time\") } 抽象类 和java一样本文不再废话 参考 密封类 java中我们存在枚举类，kotlin中也可以使用枚举类（和java用法相同）。 Kotlin中提供了另外一种形式的类，密封类。密封类，我的理解就是只能在有限的范围内定义子类（不包含间接继承）。 /** * 定义密封类使用 sealed 关键词,来尝试完成java的枚举类 */ sealed class User(val nameCore: String) { object VIP:User(\"会员\") object SUPER_VIP:User(\"超级会员\") object COMMON_VIP:User(\"普通会员\") } /** * 在kotin1.1之后支持了在密封类的继承范围,在同一个kt文件都可以直接继承 */ open class CommonUser : User(\"普通用户\") 这样定义就完成了类似java的枚举，可以看到User对象只能是有限个数的。 ==sealed修饰的类为何不能直接创建？Kotlin编译器编，默认将密封类编译成一个抽象类，所以无法直接创建对象== 密封类的好处 从上面的代码中可以看到，密封的子类还有一个非，object的CommonUser类。如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了 fun main() { /** * 注意确定了类型是User类型,不要智能类型推倒 */ val vip: User = User.VIP /** * 可以看到包含了所有的user类型,所以不在需要写else了 */ val value = when (vip) { is CommonUser -> { 0 } User.COMMON_VIP -> { 1 } User.VIP -> { 2 } User.SUPER_VIP -> { 3 } } } 类的映射typealias 在c和c++有一个宏定义，大家还记得吗（define关键字）？。在jni中我们经常这样定义，kotlin中也具有这样类似的功能。 #define TAG \"wyz\" // 这个是自定义的LOG的标识 #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) // 定义LOGD类型 #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) // 定义LOGI类型 #define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) // 定义LOGW类型 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) // 定义LOGE类型 #define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) // 定义LOGF类型 还记的as关键词在那用过吗？类型转换+导包重命名，kotlin中的typealias也具有重命名的功能（只能应用在类）。 /** * 定义类的映射 */ typealias KotlinFile = File fun main() { /** * 使用和File的功能一样 * kotlin在编译器会自动替换 */ val file:File = KotlinFile(\"ahah\") file.exists() } 补充：有没有觉得类的映射似曾相识？在集合篇章我说过，kotlin没有自己造轮子，完全使用的java的集合，但是Kotlin是怎么做到在编译器将集合映射的？其实就是用了typelias关键词 看下源码： @SinceKotlin(\"1.1\") public actual typealias RandomAccess = java.util.RandomAccess @SinceKotlin(\"1.1\") public actual typealias ArrayList = java.util.ArrayList @SinceKotlin(\"1.1\") public actual typealias LinkedHashMap = java.util.LinkedHashMap @SinceKotlin(\"1.1\") public actual typealias HashMap = java.util.HashMap @SinceKotlin(\"1.1\") public actual typealias LinkedHashSet = java.util.LinkedHashSet @SinceKotlin(\"1.1\") public actual typealias HashSet = java.util.HashSet "},"kotlin/kotlin函数+扩展函数+lambda表达式+内联函数.html":{"url":"kotlin/kotlin函数+扩展函数+lambda表达式+内联函数.html","title":"5.神奇的函数+lambda表达式+扩展函数+内联函数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 函数 定义函数 kotlin支持函数嵌套函数定义 函数定义返回值 函数默认参数 具名参数 函数指针 lambda表达式 定义lambda表达式 lambda的妙用 lambda到底是什么？ 总结 前介 扩展函数定义 扩展函数原理 扩展函数的场景 内联函数inline 内联数的return逻辑 内联函数禁止lambda表达式return和不内联 函数 定义函数 fun function(){ } kotlin支持函数嵌套函数定义 fun function(str: String) { fun function2(){ println(str) } // 调用 function2() } 函数定义返回值 fun call(str: String): Int { return str.toInt() } 函数默认参数 fun call(str: String=\"\"): Int { return str.toInt() } 具名参数 /** * 可以看到我第一个参数具有默认值,我们如何调用呢? */ fun call(str: String = \"\", msg: String): Int { return str.toInt() } /** * 这里补充下可变参数的概念 * 可变参数和java的概念一直,本质也是数组,但是java中可变参数只能放在形参末尾 * 由于kotlin有具名参数的概念,kotlin的可变参数就没必要放在末尾了 */ fun call2(vararg values: Int, msg: String) { println(\"values:${values.size} msg\") } fun main() { // 通过制定具名进行赋值 call(msg = \"啊哈哈\") call2(1, 2, 3, msg = \"msg消息\") } 函数指针 其实我也不知道函数指针这样叫对不对，但是我感觉和c中的函数指针功能相同。我们可以讲一个函数存放在一个变量中，然后传递。 /** * 定义一个函数 * 这里用类一个缩写,只要函数只有执行一句代码,就可以这样写 */ fun func1(msg: String) = println(msg) /** * 高潮部分,函数传递 * (这里说了提前预备了下lambda的知识,先不要考虑Function1是个什么东东,只管是个函数类型的对象吧) * */ fun func2(tag: String, funCall: Function1) { funCall(\"tag:$tag\") } fun main() { /** * 通过::获取函数的指针 */ val f = ::func1 /** * 传递函数 */ func2(\"wyz\", f) } lambda表达式 kotlin将lambda发挥到了极致，机会随处可见。原理其实也很简单，接下来我们脱光他的衣服。前面我们说过，函数指针，那他的本质到底是什么呢？首先我们从lambda表达式入手。 定义lambda表达式 /** * 定义了一个简单的lambda表达式 */ val lambdaFun = { msg: String -> println(msg) } // 调用也很简单 lambdaFun(\"111\") lambdaFun.invoke(\"222\") lambda类似函数，也具有形参和返回值，返回值位最后一句代码的返回值（可以不写return。注意是lambda表达式不用写return，不是定义的函数） lambda的妙用 在kotlin中，如果一个方法接收一个接口，并且这个接口只有一个方法，可以直接传递一个lambda表达式 最常见的view点击事件： myView.setOnClickListener { } 在 lambda到底是什么？ 反编译我们的代码，看看到底是什么？ private static final Function1 lambdaFun; ==可以发现lambdaFun对应的是Function1，是不是很眼熟，Function1不是前面的函数指针说过的东西？我们可以验证下结论== /** * 这2个函数是不是一个东西啊??? */ fun func1(msg: String) = println(msg) val lambdaFun = { msg: String -> println(msg) } /** * 验证下结论 */ fun main() { val f1 = ::func1 println(\"func1类型的对象:${f1 is Function1}\") println(\"lambdaFun类型的对象:${lambdaFun is Function}\") } // 输出结果 func1类型的对象:true lambdaFun类型的对象:true 总结 最终我们知道了，lambda最终会被编译器编译成FunctionN的对象，这里的N代表的对应参数数量。哪最多支持多少个参数的lambda参数呢？查看下kotlin.jvm.functions的类,可以发现能最多能定义22个参数的lambda表达式。那有些杠精问了，那如果我要定义超过22个参数的呢？我的解决放啊是通过可变参数。 .... /** A function that takes 22 arguments. */ public interface Function22 : Function { /** Invokes the function with the specified arguments. */ public operator fun invoke(p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9, p10: P10, p11: P11, p12: P12, p13: P13, p14: P14, p15: P15, p16: P16, p17: P17, p18: P18, p19: P19, p20: P20, p21: P21, p22: P22): R } 这里有必要说下，形参传递lambda表达式（其实就是传递的FunctionN对象） /** * 可以看到传递的参数lambdaCall类型是 () -> String 这个类型等价于 Function0 */ fun call(lambdaCall: () -> String) { lambdaCall() } 前介 不得不说kotlin的扩展函数和lambda简直将kotlin推向了高潮。他给使用kotlin的开发者中增加了无限的想象。曾经我们常用的方法，经常都是抽取一个静态类中静态方法。这种形式比较难处理，经常我们开发中遇到需要对字符串进行的处理的一个常用的方法，还需要通过去找utils包，寻找此方法（有时候还不一定在utils包下），不得不重复造轮子。后续讲到的kotlin的高阶函数，大部分都是通过扩展方法实现的。 扩展函数定义 举个例子：我们经常数组有一个交换操作，我们如果想给所有的集合都添加一个功能。 fun main() { val arrays = arrayOf(\"1\", \"2\", \"3\") arrays.swap(0, 1) } /** * 定义扩展扩展方法swap,我们是定义在了Array扩展上 */ fun Array.swap(v1: Int, v2: Int) { val tmp = this[v1] this[v2] = this[v1] this[v1] = tmp } 扩展函数原理 kotlin中扩展函数，是为对应类的扩展函数添加了一个静态方法（一定要记住是静态方法），并且第一个参数就是对象本身。 open class Parent fun Parent.call() = \"parent\" class Child : Parent() { fun call() = \"child\" } fun call(parent: Parent) { println(parent.call()) } /** * 验证下结论 */ fun main() { // 最终输出 parent 证明了,扩展函数生成的函数是静态函数(并不是真正意义上的定义在对应类中) call(Child()) } 扩展函数的场景 数组map转换： // 发现所有的Array扩展了一个map函数，map函数和rxjava的一样，可以将数据流转换成另外一种类型的流 public inline fun Array.map(transform: (T) -> R): List { return mapTo(ArrayList(size), transform) } public inline fun > Array.mapTo(destination: C, transform: (T) -> R): C { for (item in this) destination.add(transform(item)) return destination } 数组遍历forEach&forEachIndexed： // 太简单不想说 public inline fun Array.forEach(action: (T) -> Unit): Unit { for (element in this) action(element) } public inline fun Array.forEachIndexed(action: (index: Int, T) -> Unit): Unit { var index = 0 for (item in this) action(index++, item) } 内联函数inline 我们说过kotlon的lambda表达式，最终都会编译成一个FunctionN的一个对象，然后执行。试想下当kotlin的一个方法中lambda有很多个，不就在方法中创建了很多的对象吗？性能上，内存上都是一个不必要的浪费。我们可以看下高阶函数的apply，let，run他们定义的时候都通过inline修饰，根本原因就是这些方法经常使用，我们不必要再进行多余的对象。直接在编译时期将我们的代码平铺到对应方法即可。 /** * 调用执行 */ fun main() { call { println(\"3\") } } /** * 未经过inline修饰的fun方法 */ fun call(block: () -> Unit) { println(\"1\") block() println(\"2\") } 看下java源码： public final class KotlinInlineKt { public static final void main() { // 1. 可以看到创建了一个Function0的对象，并且调用了call方法 call((Function0)null.INSTANCE); } // $FF: synthetic method public static void main(String[] var0) { main(); } // 2.call方法的定义没啥好说的 public static final void call(@NotNull Function0 block) { Intrinsics.checkParameterIsNotNull(block, \"block\"); String var1 = \"1\"; boolean var2 = false; System.out.println(var1); block.invoke(); var1 = \"2\"; var2 = false; System.out.println(var1); } } ==接下来我们尝试通过inline修饰方法== /** * 调用执行 */ fun main() { call { println(\"3\") } } /** * 经过inline修饰的fun方法 */ inline fun call(block: () -> Unit) { println(\"1\") block() println(\"2\") } java源码分析： public final class KotlinInlineKt { // 1. 看main方法都不调用call方法了和创建lambda对应的FunctionN对象了，直接将call方法的代码拷贝了一份（看上去打破了java的方法抽取服用的概念） public static final void main() { int $i$f$call = false; String var1 = \"1\"; boolean var2 = false; System.out.println(var1); int var3 = false; String var4 = \"3\"; boolean var5 = false; System.out.println(var4); var1 = \"2\"; var2 = false; System.out.println(var1); } // $FF: synthetic method public static void main(String[] var0) { main(); } // 2.call方法的定义没啥好说的 public static final void call(@NotNull Function0 block) { int $i$f$call = 0; Intrinsics.checkParameterIsNotNull(block, \"block\"); String var2 = \"1\"; boolean var3 = false; System.out.println(var2); block.invoke(); var2 = \"2\"; var3 = false; System.out.println(var2); } } 通过上面的学习，我们应该大体了解了一些内联函数。感觉内联函数在编译器会将代码从新拷贝一份对应的调用函数中去。试想下这样的坏处，就是单独的class文件的体积会变大。（怪不得kotlin的项目体积明显比java想的大） 内联数的return逻辑 ==大家有没有考虑过，内涵函数既然是平铺代码，那我函数中定义的return语句会如何执行呢？== 给大家总结下：inline修饰的函数，函数中return不会中断调用函数。lambda中return会中断函数调用。看下面例子就明白啦！ /** * 调用执行 */ fun main() { call { println(\"2\") } println(\"4\") } /** * 经过inline修饰的fun方法 */ inline fun call(block: () -> Unit) { println(\"1\") block() println(\"3\") /** *这个return不会中断调用函数 */ return } 输出结果： 1 2 3 4 /** * 调用执行 */ fun main() { call { println(\"2\") /** * 这个return会中断调用函数 */ return } println(\"4\") } /** * 经过inline修饰的fun方法 */ inline fun call(block: () -> Unit) { println(\"1\") block() println(\"3\") /** *这个return不会中断调用函数 */ return } 输出结果： 1 2 内联函数禁止lambda表达式return和不内联 哪小朋友又问了，比如我想定义一个inline函数。对应方法的lambda表达式又不想让其中断调用函数或者lambda不要内联怎么呢？ 通过crossinline关键词修饰的lambda表达式不可以return /** * 经过inline修饰的fun方法 * 通过 crossinline 关键词修饰lambda表达式,表示这个表达式在inline函数中无法中断调用函数 */ inline fun call(crossinline block: () -> Unit) { println(\"1\") block() println(\"3\") /** *这个return不会中断调用函数 */ return } 通过noinline关键词修饰的lambda表达式不会被平铺代码，还以FunctionN的对象调用 /** * 经过inline修饰的fun方法 * 通过 noinline 关键词修饰lambda表达式,表示这个表达式在inline函数中,lambda不会被平铺代码.最终还是会以Function对象的形式调用 */ inline fun call(noinline block: () -> Unit) { println(\"1\") block() println(\"3\") /** *这个return不会中断调用函数 */ return } "},"kotlin/Kotlin作用域函数.html":{"url":"kotlin/Kotlin作用域函数.html","title":"6.作用域函数","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 前介 作用域函数 常见的作用域函数 run操作符 let操作符 apply操作符 also操作符 takeIf操作符 takeUnless表达式 总结 前介 在kotlin扩展函数和函数可以变成参数的功能加持上，我们kotlin为我们提供了一系列的作用域函数（本质上还是通过扩展函数实现的）。 作用域函数 什么事作用域函数，就是所有的对象，都可以使用这些函数。进行操作和转换。 常见的作用域函数 run操作符 fun main() { val data = Data(\"阿文\", 18) val reslut = data.run { name = \"阿文2\" \"修改完成\" } println(reslut) println(data.name) } > 输出结果： 修改完成 阿文2 > 源码分析： public inline fun T.run(block: T.() -> R): R { 。。。 return block() } run参数传递的lambda表达式是T类型的扩展函数，所以this对应的就是T类型，返回值是lambda表达式允许的结果 let操作符 fun main() { val data = Data(\"阿文\", 18) val reslut = data.let { it.name = \"阿文2\" \"修改完成\" } println(reslut) println(data.name) } 输出结果：修改完成阿文2 源码分析： public inline fun T.let(block: (T) -> R): R { ... return block(this) } let操作符和run操作功能类似，只是lambda表达式对应的一个是扩展函数，一个不是。 apply操作符 data class Data(var name: String, var age: Int) fun main() { val data = Data(\"阿文\", 18) val reslut = data.apply { name = \"阿文2\" \"修改完成\" } println(reslut) println(data.name) } 输出结果:Data(name=阿文2, age=18)阿文2 源码分析： public inline fun T.apply(block: T.() -> Unit): T { 。。。 block() return this } 可以看到apply对应传递lambda属于一个T的扩展函数和run一样，但是返回值不在是lambda表达式的返回值，而是this了。 also操作符 fun main() { val data = Data(\"阿文\", 18) val reslut = data.also { it.name = \"阿文2\" \"修改完成\" } println(reslut) println(data.name) } 输出结果:Data(name=阿文2, age=18)阿文2 源码分析： public inline fun T.also(block: (T) -> Unit): T { 。。。 block(this) return this } 可以看到also对应传递lambda属于let一样（lambda接收一个T类型的参数），但是返回值不在是lambda表达式的返回值，而是this了。 takeIf操作符 public inline fun T.takeIf(predicate: (T) -> Boolean): T? { 。。。 return if (predicate(this)) this else null } 可以发现就是判断就是lambda表达式返回ture，就会返回this对象，否则就是null takeUnless表达式 public inline fun T.takeUnless(predicate: (T) -> Boolean): T? { 。。。 return if (!predicate(this)) this else null } 和takeIf相反 总结 最好的方式对比学习。 操作符 功能 let lambda表达式属于对应对象的扩展函数，返回值是lambda的返回值 run lambda表达式的只有一个参数是对应对象，返回值是lambda的返回值 apply lambda表达式的只有一个参数是对应对象，返回值对应对象 also lambda表达式的只有一个参数是对应对象，返回值是对应对象 takeIf lambda表达式的只有一个参数是对应对象，返回值若lambda表达式true，返回this，否则返回null takeUnless lambda表达式的只有一个参数是对应对象，返回值若lambda表达式false，返回this，否则返回null（和takeIf相反） 大家有没有考虑，为啥koltin要提供一些这些作用域函数呢？ 举个例子： 当我们收到一个user实体，里面有账号密码，判断密码是否正确，如果正确提示返回登录信息，否则错误提示。 ==其实还有一个with的作用域函数，但是我觉得这个东西很鸡肋（完全和run的功能一样），如果想学习，就看下源码吧== public inline fun with(receiver: T, block: T.() -> R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return receiver.block() } "},"kotlin/超牛B的操作符重载+中缀符.html":{"url":"kotlin/超牛B的操作符重载+中缀符.html","title":"7.超牛B的操作符重载+中缀符","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 前介 重载操作符的运用 数组相加 list集合相加减 如何自定义重载操作符 可重载的操作符 一元操作符 二元操作符 in操作符 索引操作符 调用操作符 广义赋值 相等与不等操作符 比较操作符 中缀表达式 中缀表达式的运用 自定义中缀表达式 前介 在C或C++中，是存在操作符重载的概念的。在java中我们认知的+-*/只能作用在数字的类型中做计算。而在kotlin中将不再是唯一，我们可以通过操作符重载的形式，改变其含义。 重载操作符的运用 数组相加 fun main() { /** * 创建2个数组 */ val array1 = arrayOf(\"1\", \"2\", \"3\") val array2 = arrayOf(\"4\", \"5\", \"6\") val array3 = array1 + array2 /** * 遍历输出 */ array3.forEach(::println) } 输出结果： 1 2 3 4 5 6 可以看到，2个数组合并了。在java的世界中，不存在数组相加的情况 list集合相加减 fun main() { /** * 创建2个可变集合 */ val list1 = mutableListOf(\"1\", \"2\", \"3\") val list2 = mutableListOf(\"1\", \"5\", \"6\") /** * 集合相加 */ val list3 = list1 + list2 /** * 遍历输出 */ list3.forEach(::println) println(\"========减法===========\") /** * 集合相减 */ val minusResult = list1 - list2 /** * 遍历输出减法 */ minusResult.forEach(::println) } 输出结果： 1 2 3 1 5 6 ========减法=========== 2 3 从结果可以看出，相加合并2个list集合。相减含义是去除减数在被减数中存在的元素==map也是支持相加减的，有兴趣的可以自己去尝试== 如何自定义重载操作符 如果想重载操作符，关键词operator修饰方法即可，对应重载的操作符对应一个方法，这个形式就对应是要+的对象。举个例子，如果我想为我自己定义的对象重载+的操作符。 /** * 程序员实体 */ data class CodePeople(val name: String, val age: Int) /** * UI实体 */ data class UiPeople(val name: String, val age: Int) /** * 团队 */ data class Tream( val codes: MutableList = mutableListOf() , val uis: MutableList = mutableListOf() ) { /** * 重载加法 关键词operator * 这里要注意 一定要有一个参数,参数就是需要加的对象 */ operator fun plus(code: CodePeople) { codes.add(code) } /** * 我们可以重载很多类型的 操作符 */ operator fun plus(ui: UiPeople) { uis.add(ui) } } /** * 测试 */ fun main() { val tream = Tream() /** * 可以看到可以调用 +了 */ tream + CodePeople(\"阿文\", 18) tream + UiPeople(\"小丽\", 18) } ==一般来说，重载方法都已扩展函数的形式去编写。== 可重载的操作符 一元操作符 操作符 对应重载函数 +a a.unaryPlus() -a a.unaryMinus() !a a.not() a++ a.inc() a-- a.dec() 二元操作符 操作符 对应重载函数 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b)、 a.mod(b) （已弃用） a..b a.rangeTo(b) in操作符 操作符 对应重载函数 a in b b.contains(a) a !in b !b.contains(a) 索引操作符 操作符 对应重载函数 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, ……, i_n] a.get(i_1, ……, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, ……, i_n] = b a.set(i_1, ……, i_n, b) 调用操作符 操作符 对应重载函数 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, ……, i_n) a.invoke(i_1, ……, i_n) 广义赋值 操作符 对应重载函数 a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b), a.modAssign(b)（已弃用） 相等与不等操作符 操作符 对应重载函数 a == b a?.equals(b) ?: (b === null) a != b !(a?.equals(b) ?: (b === null)) 比较操作符 操作符 对应重载函数 a > b a.compareTo(b) > 0 a a.compareTo(b) a >= b a.compareTo(b) >= 0 a a.compareTo(b) 中缀表达式 我们前面说过重载操作符，都是一般常用的运算符。那我们能不能类似自定义一个操作符呢？比如将一些无意义的关键词变的有意义？ 中缀表达式的运用 还记的集合篇章的可变的map定义吗？其实这里面的to就是一个中缀表达式，将to关键词从无意义变成了有意义 fun main() { val results = mutableMapOf(\"阿文\" to 18, \"小丽\" to 18) } 看下to的定义，可以看到中缀表达式的关键词infix。最终定义的效果就是使用to，会生成一个Pair对象，mutableMapOf刚好需要这种类型的实体 public infix fun A.to(that: B): Pair = Pair(this, that) 自定义中缀表达式 /** * 程序员实体 */ data class CodePeople(val name: String, val age: Int) /** * UI实体 */ data class UiPeople(val name: String, val age: Int) /** * 团队 */ data class Tream( val codes: MutableList = mutableListOf() , val uis: MutableList = mutableListOf() ) { /** * 中缀表达式 addAll 合并2个Tream */ infix fun addAll(tram: Tream) { codes.addAll(tram.codes) uis.addAll(tram.uis) } } /** * 测试 */ fun main() { val tream1 = Tream() val tream2 = Tream() /** * 合并 */ tream1 addAll tream2 } "}}